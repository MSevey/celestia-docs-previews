"use strict";(self.webpackChunkcelestia_docs=self.webpackChunkcelestia_docs||[]).push([[7241],{4137:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>h});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,u=r(e,["components","mdxType","originalType","parentName"]),p=c(n),m=o,h=p["".concat(l,".").concat(m)]||p[m]||d[m]||i;return n?a.createElement(h,s(s({ref:t},u),{},{components:n})):a.createElement(h,s({ref:t},u))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,s=new Array(i);s[0]=m;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r[p]="string"==typeof e?e:o,s[1]=r;for(var c=2;c<i;c++)s[c]=n[c];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},8496:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>i,metadata:()=>r,toc:()=>c});var a=n(7462),o=(n(7294),n(4137));const i={},s="Submitting data blobs to Celestia",r={unversionedId:"learn/submit-data",id:"learn/submit-data",title:"Submitting data blobs to Celestia",description:"To submit data to Celestia, users submit blob transactions (BlobTx). Blob",source:"@site/docs/learn/submit-data.md",sourceDirName:"learn",slug:"/learn/submit-data",permalink:"/pr-preview/pr-1/learn/submit-data",draft:!1,editUrl:"https://github.com/celestiaorg/docs/tree/main/docs/learn/submit-data.md",tags:[],version:"current",frontMatter:{},sidebar:"learn",previous:{title:"Paying for blobspace",permalink:"/pr-preview/pr-1/category/paying-for-blobspace"},next:{title:"Specifications",permalink:"/pr-preview/pr-1/category/specifications"}},l={},c=[{value:"Fee market and mempool",id:"fee-market-and-mempool",level:2},{value:"Fees and gas limits",id:"fees-and-gas-limits",level:3},{value:"Estimating PFB gas",id:"estimating-pfb-gas",level:4},{value:"Estimating gas programmatically",id:"estimating-gas-programmatically",level:4},{value:"Submitting multiple transactions in one block from the same account",id:"submitting-multiple-transactions-in-one-block-from-the-same-account",level:3},{value:"API",id:"api",level:2},{value:"The celestia-app consensus node CLI",id:"the-celestia-app-consensus-node-cli",level:3},{value:"The celestia-node light node CLI",id:"the-celestia-node-light-node-cli",level:3},{value:"GRPC to a consensus node via the <code>user</code> package",id:"grpc-to-a-consensus-node-via-the-user-package",level:3},{value:"RPC to a celestia-node",id:"rpc-to-a-celestia-node",level:3}],u={toc:c},p="wrapper";function d(e){let{components:t,...n}=e;return(0,o.kt)(p,(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"submitting-data-blobs-to-celestia"},"Submitting data blobs to Celestia"),(0,o.kt)("p",null,"To submit data to Celestia, users submit blob transactions (",(0,o.kt)("inlineCode",{parentName:"p"},"BlobTx"),"). Blob\ntransactions contain two components, a standard Cosmos-SDK transaction called\n",(0,o.kt)("inlineCode",{parentName:"p"},"MsgPayForBlobs")," and a ",(0,o.kt)("inlineCode",{parentName:"p"},"Blob")," of data."),(0,o.kt)("h2",{id:"fee-market-and-mempool"},"Fee market and mempool"),(0,o.kt)("p",null,"Celestia makes use of a standard gas-priced prioritized mempool. By default,\ntransactions with fees higher than that of other transactions in the mempool\nwill be prioritized by validators."),(0,o.kt)("h3",{id:"fees-and-gas-limits"},"Fees and gas limits"),(0,o.kt)("p",null,"As of version v1.0.0 of the application (celestia-app), there is no protocol\nenforced protocol minimum fee (similar to EIP-1559 in Ethereum). Instead, each\nconsensus node running a mempool uses a locally configured gas price threshold\nthat must be met in order for that node to accept a transaction, either directly\nfrom a user or gossiped from another node, into its mempool."),(0,o.kt)("p",null,"As of version v1.0.0 of the application (celestia-app), gas is not refunded.\nInstead, transaction fees are deducted by a flat fee, originally determined by\nthe user via multiplying the gas limit by the desired gas price. This means that\nusers should use an accurate gas limit value if they do not wish to over pay."),(0,o.kt)("p",null,"Under the hood, fees are currently handled by specifying and deducting a flat\nfee. However gas price is often specifed by users instead of calculating the\nflat fee from the gas used and the gas price. Since the state machine does not\nrefund users for unused gas, gas price is calculated by dividing the total fee\nby the gas limit."),(0,o.kt)("h4",{id:"estimating-pfb-gas"},"Estimating PFB gas"),(0,o.kt)("p",null,'Generally, the gas used by a PFB transaction involves a static "fixed cost" and\na dynamic cost based on the size of each blob involved in the transaction.'),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Note: For a general use case of a normal account submitting a PFB, the static\ncosts can be treated as such. However, due to the description above of how gas\nworks in the Cosmos-SDK this is not always the case. Notably, if we use a\nvesting account or the ",(0,o.kt)("inlineCode",{parentName:"p"},"feegrant")," modules, then these static costs change.")),(0,o.kt)("p",null,'The "fixed cost" is an approximation of the gas consumed by operations outside\nthe function ',(0,o.kt)("inlineCode",{parentName:"p"},"GasToConsume")," (for example, signature verification, tx size, read\naccess to accounts), which has a default value of 65,000 gas."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Note: the first transaction sent by an account (sequence number == 0) has an\nadditional one time gas cost of 10,000 gas. If this is the case, this\nshould be accounted for.")),(0,o.kt)("p",null,"Each blob in the PFB contributes to the total gas cost based on its size. The\nfunction ",(0,o.kt)("inlineCode",{parentName:"p"},"GasToConsume")," calculates the total gas consumed by all the blobs\ninvolved in a PFB, where each blob's gas cost is computed by first determining\nhow many shares are needed to store the blob size. Then, it computes the product\nof the number of shares, the number of bytes per share, and the ",(0,o.kt)("inlineCode",{parentName:"p"},"gasPerByte"),"\nparameter. Finally, it adds a static amount per blob."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"GasCostPerBlobByte")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"GasCostPerTransactionByte")," are parameters that\ncould potentially be adjusted through the system's governance mechanisms. Hence,\nactual costs may vary depending on the current state of these parameters."),(0,o.kt)("h4",{id:"estimating-gas-programmatically"},"Estimating gas programmatically"),(0,o.kt)("p",null,"Users can estimate an efficient gas limit by using this function:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'import (\n    blobtypes "github.com/celestiaorg/celestia-app/x/blob/types"\n)\ngasLimit := blobtypes.DefaultEstimateGas([]uint32{uint32(sizeOfDataInBytes)})\n')),(0,o.kt)("p",null,"If using a celestia-node light client, then this function is automatically\ncalled for you when submitting a blob. This function works by breaking down the\ncomponents of calculating gas for a blob transaction. These components consist\nof a flat costs for all PFBs, the size of each blob and how many shares each\nuses and the parameter for gas used per byte. More information about how gas is\nused can be found in the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/celestiaorg/celestia-app/blob/d17e231ae3a0150b50a1854f3e9a268c34502b6b/specs/src/specs/resource_pricing.md"},"gas\nspecs"),"\nand the exact formula can be found in the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/celestiaorg/celestia-app/blob/d17e231ae3a0150b50a1854f3e9a268c34502b6b/x/blob/types/payforblob.go#L157-L181"},"blob\nmodule"),"."),(0,o.kt)("h3",{id:"submitting-multiple-transactions-in-one-block-from-the-same-account"},"Submitting multiple transactions in one block from the same account"),(0,o.kt)("p",null,"The mempool Celestia uses works by maintaining a fork of the canonical state\neach block. This means that each time we submit a transaction to it, it will\nupdate the sequence number (aka nonce) for the account that submitted the\ntransaction. If users wish to submit a second transaction, they can, but must\nspecify the nonce manually. If this is not done, the new transactions will not\nbe able to be submitted until the first transaction is reaped from the mempool (i.e. included in a block), or dropped due to timing out."),(0,o.kt)("p",null,"By default, nodes will drop a transaction if it does not get included in 10\nblocks (roughly 2.5 minutes). At this point, the user must resubmit their\ntransaction if they want it to eventually be included."),(0,o.kt)("p",null,"As of v1.0.0 of the application (celestia-app), users are unable to replace an\nexisting transaction with a different one with higher fees. They must instead\nwait 10 blocks from the original submitted time and then resubmit the\ntransaction. Again, community members have already suggested solutions and a\nwillingness to accept changes to fix this issue."),(0,o.kt)("h2",{id:"api"},"API"),(0,o.kt)("p",null,"Users can currently create and submit ",(0,o.kt)("inlineCode",{parentName:"p"},"BlobTx"),"s in four ways."),(0,o.kt)("h3",{id:"the-celestia-app-consensus-node-cli"},"The celestia-app consensus node CLI"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-terminal"},"celestia-appd tx blob PayForBlobs <hex encoded namespace> <hex encoded data> [flags]\n")),(0,o.kt)("h3",{id:"the-celestia-node-light-node-cli"},"The celestia-node light node CLI"),(0,o.kt)("p",null,"Using ",(0,o.kt)("inlineCode",{parentName:"p"},"blob.Submit"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-terminal"},"celestia rpc blob submit <namespace in hex> <data in hex>\n")),(0,o.kt)("p",null,"Learn more in the ",(0,o.kt)("a",{parentName:"p",href:"../../developers/node-tutorial"},"node tutorial"),"."),(0,o.kt)("h3",{id:"grpc-to-a-consensus-node-via-the-user-package"},"GRPC to a consensus node via the ",(0,o.kt)("inlineCode",{parentName:"h3"},"user")," package"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'import (\n    "context"\n    "fmt"\n\n    "github.com/celestiaorg/celestia-app/app"\n    "github.com/celestiaorg/celestia-app/app/encoding"\n    "github.com/celestiaorg/celestia-app/pkg/appconsts"\n    "github.com/celestiaorg/celestia-app/pkg/namespace"\n    "github.com/celestiaorg/celestia-app/pkg/user"\n    blobtypes "github.com/celestiaorg/celestia-app/x/blob/types"\n    "github.com/cosmos/cosmos-sdk/crypto/keyring"\n    tmproto "github.com/tendermint/tendermint/proto/tendermint/types"\n    "google.golang.org/grpc"\n    "google.golang.org/grpc/credentials/insecure"\n)\n\n// SubmitData is a demo function that shows how to use the signer to submit data\n// to the blockchain directly via a celestia node. We can manage this keyring\n// using the `celestia-appd keys` or `celestia keys` sub commands and load this\n// keyring from a file and use it to programmatically sign transactions.\nfunc DemoSubmitData(grpcAddr string, kr keyring.Keyring) error {\n    // create an encoding config that can decode and encode all celestia-app\n    // data structures.\n    ecfg := encoding.MakeConfig(app.ModuleEncodingRegisters...)\n\n    // create a connection to the grpc server on the consensus node.\n    conn, err := grpc.Dial(grpcAddr, grpc.WithTransportCredentials(insecure.NewCredentials()))\n    if err != nil {\n        return err\n    }\n    defer conn.Close()\n\n    // get the address of the account we want to use to sign transactions.\n    rec, err := kr.Key("accountName")\n    if err != nil {\n        return err\n    }\n\n    addr, err := rec.GetAddress()\n    if err != nil {\n        return err\n    }\n\n    // Setup the signer. This function will automatically query the relevant\n    // account information such as sequence (nonce) and account number.\n    signer, err := user.SetupSigner(context.TODO(), kr, conn, addr, ecfg)\n    if err != nil {\n        return err\n    }\n\n    ns := namespace.MustNewV0([]byte("1234567890"))\n\n    fmt.Println("namepace", len(ns.Bytes()))\n\n    blob, err := blobtypes.NewBlob(ns, []byte("some data"), appconsts.ShareVersionZero)\n    if err != nil {\n        return err\n    }\n\n    gasLimit := blobtypes.DefaultEstimateGas([]uint32{uint32(len(blob.Data))})\n\n    options := []user.TxOption{\n        // here we\'re setting estimating the gas limit from the above estimated\n        // function, and then setting the gas price to 0.1utia per unit of gas.\n        user.SetGasLimitAndFee(gasLimit, 0.1),\n    }\n\n    // this function will submit the transaction and block until a timeout is\n    // reached or the transaction is committed.\n    resp, err := signer.SubmitPayForBlob(context.TODO(), []*tmproto.Blob{blob}, options...)\n    if err != nil {\n        return err\n    }\n\n    // check the response code to see if the transaction was successful.\n    if resp.Code != 0 {\n        // handle code\n        fmt.Println(resp.Code, resp.Codespace, resp.RawLog)\n    }\n\n    // if we don\'t want to wait for the transaction to be confirmed, we can\n    // manually sign and submit the transaction using the same package.\n    blobTx, err := signer.CreatePayForBlob([]*tmproto.Blob{blob}, options...)\n    if err != nil {\n        return err\n    }\n\n    resp, err = signer.BroadcastTx(context.TODO(), blobTx)\n    if err != nil {\n        return err\n    }\n\n    // check the response code to see if the transaction was successful. Note\n    // that this time we\'re not waiting for the transaction to be committed.\n    // Therefore the code here is only from the consensus node\'s mempool.\n    if resp.Code != 0 {\n        // handle code\n        fmt.Println(resp.Code, resp.Codespace, resp.RawLog)\n    }\n\n    return err\n}\n')),(0,o.kt)("h3",{id:"rpc-to-a-celestia-node"},"RPC to a celestia-node"),(0,o.kt)("p",null,"Using the JSON RPC API, submit data using the following methods:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"/api/v0.11.0-rc13/#blob.Submit"},"blob.Submit")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"/api/v0.11.0-rc13/#state.SubmitPayForBlob"},"state.SubmitPayForBlob"))),(0,o.kt)("p",null,"Learn more in the ",(0,o.kt)("a",{parentName:"p",href:"/api/v0.11.0-rc13"},"celestia-node API docs"),"."))}d.isMDXComponent=!0}}]);